/*
  Linker file for MKL05Z4 series microcontrollers
  References:
  https://github.com/ARM-software/CMSIS_5/blob/develop/Device/ARM/ARMCM0plus/Source/GCC/gcc_arm.ld
  https://blog.thea.codes/the-most-thoroughly-commented-linker-script/
*/

/*
  Size according to KL05 Sub-Family Reference Manual, Rev. 3.1
  2.5 Orderable part numbers table
  Default stack size 256 bytes
*/
FLASH_SIZE = 0x8000;
SRAM_SIZE = 0x1000;
__STACK_SIZE = DEFINED(__stack_size) ? __stack_size : 0x100;

/*
  Memory section definitions
  As the flash configuration field is just after the vectors, both of them
  are defined in separate sections.
*/
MEMORY
{
  flash_start(rx): ORIGIN = 0x00000000, LENGTH = 0x000000C0
  cfmprotrom(rx):  ORIGIN = 0x00000400, LENGTH = 0x00000010
  flash(rx):       ORIGIN = 0x00000410, LENGTH = FLASH_SIZE - 0x410
  sram(rwx):       ORIGIN = 0x1FFFFC00, LENGTH = SRAM_SIZE
}

/*
On embedded systems ENTRY directive is useful only to have correct ENTRY in ELF file for
debugging purpose.
*/
ENTRY(Reset_Handler)

/*
  Section for defining sections and symbol values.
  It references following symbols, which must be defined in code:
  Reset_Handler : Entry of reset handler

  It defines following symbols, which code can use without definition:
  __exidx_start
  __exidx_end
  __copy_table_start__
  __copy_table_end__
  __zero_table_start__
  __zero_table_end__
  __etext
  __data_start__
  __preinit_array_start
  __preinit_array_end
  __init_array_start
  __init_array_end
  __fini_array_start
  __fini_array_end
  __data_end__
  __bss_start__
  __bss_end__
  __end__
  end
  __HeapLimit
  __StackLimit
  __StackTop
  __stack
*/
SECTIONS
{
    /*
      The vector table defines the initial stack pointer and
      interrupt/exception routines for the ARM CPU and device
      peripherals. Every Cortex-M project needs this.

      When defining the vector table `__attribute__ ((section(".vectors")))` 
      has to be used to tell the compiler to place the vector table
      into the section named ".vectors" in the input object file so that
      the linker can find it.
      
      To save on size, the firmware is compiled with options 
      that let the compiler discard unused functions 
      and data (`--gc-sections`).
      Without `KEEP`, the linker would remove vector table.
    */
  .interrupts :
  {
    . = ALIGN(4);
    KEEP(*(.vectors .vectors.*))
    . = ALIGN(4);
  } > flash_start
  
  /*
    For this microcontroller series an additional section has to be defined.
    It contains configuration of flash security and backdoor key to unlock it.
    More information can be found in: 27.3.1 Flash Configuration Field Description
    in KL05 Sub-Family Reference Manual, Rev. 3.1
  */

  .cfmprotect :
  {
    . = ALIGN(4);
    KEEP(*(.cfmconfig))	/* Flash Configuration Field (FCF) */
    . = ALIGN(4);
  } > cfmprotrom

  /*
    The text segment contains program code and read-only data.
    https://developer.arm.com/documentation/dui0101/a/ page 5, Segments
  */
  .text : {
    /*
      This segment must be 4-byte aligned as defined in ARM ELF
      File Format specification.
    */
    . = ALIGN(4);   

    /*
      Include code and read-only data sections from all
      input files.

      By default, GCC places all program code into a section named
      ".text" and read-only data (such as const static variables) into
      a section named ".rodata" in the input object files. This naming
      convention is from the ELF ABI specification.

      GCC generates three "flavors" of sections in object files:

      - .{section}: the basic section.
      - .{section}.*: sections generated by "-ffunction-sections" and
        "-fdata-sections" so that each function/data has a unique
        section.
      - .gnu.linkonce.{type}.*: sections generated by GCC so the
        linker can remove duplicates. Seems to be related to
        Vague Linking.

      References:
      * http://www.sco.com/developers/gabi/latest/ch4.sheader.html#special_sections
      * https://gcc.gnu.org/onlinedocs/gcc/Vague-Linkage.html
      * https://stackoverflow.com/questions/5518083/what-is-a-linkonce-section
    */
    *(.text .text.* .gnu.linkonce.t.*)
    *(.rodata .rodata* .gnu.linkonce.r.*)

    /*
      The following sections support the C & C++ runtime.

      These are generally used by crt0.

      References:
      * https://en.wikipedia.org/wiki/Crt0
    */

    /*
      C++ Runtime: initializers for static variables.
      C Runtime: designated constructors

      For C++, handles variables at file scope like this:

        int f = some_func()

      For C, handles functions designated as constructors:

        void intialize_thing(void) __attribute__((constructor));

      Executed by the C runtime at startup via __libc_init_array.

      References:
      * https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c
      * https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/misc/init.c;
      * https://gcc.gnu.org/onlinedocs/gccint/Initialization.html
      * https://developer.arm.com/documentation/dui0475/h/the-arm-c-and-c---libraries/c---initialization--construction-and-destruction
      * https://stackoverflow.com/questions/15265295/understanding-the-libc-init-array
    */
    . = ALIGN(4);
    KEEP(*(.init))

    . = ALIGN(4);
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array))
    PROVIDE_HIDDEN (__preinit_array_end = .);

    . = ALIGN(4);
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT(.init_array.*)))
    KEEP (*(.init_array))
    PROVIDE_HIDDEN (__init_array_end = .);
    
    /*
      C++ runtime: destructors for static variables.
      C runtime: designated finializers

      For C, handles functions designated as destructors:

        void destroy_thing(void) __attribute__((destructor));

      References:
      * https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/misc/fini.c
    */
    . = ALIGN(4);
    KEEP(*(.fini))

    . = ALIGN(4);
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(.fini_array))
    KEEP (*(SORT(.fini_array.*)))
    PROVIDE_HIDDEN (__fini_array_end = .);

    /*
      C++ runtime: static constructors

      References:
      * https://gcc.gnu.org/onlinedocs/gccint/Initialization.html
      * https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c
    */
    . = ALIGN(4);
    KEEP (*crtbegin.o(.ctors))
    KEEP (*(EXCLUDE_FILE (*crtend.o) .ctors))
    KEEP (*(SORT(.ctors.*)))
    KEEP (*crtend.o(.ctors))

    /*
      C++ runtime: static destructors and atexit()

      Note that in usual practice these aren't ever called because the program
      doesn't exit - except when powered off or reset.

      References:
      * https://gcc.gnu.org/onlinedocs/gccint/Initialization.html
      * https://github.com/gcc-mirror/gcc/blob/master/libgcc/crtstuff.c
    */
    . = ALIGN(4);
    KEEP (*crtbegin.o(.dtors))
    KEEP (*(EXCLUDE_FILE (*crtend.o) .dtors))
    KEEP (*(SORT(.dtors.*)))
    KEEP (*crtend.o(.dtors))

    . = ALIGN(4);
   } > flash


  /*
    ARM defines several special sections for exception handling
    called Special Section Indexes

    These are required for C++ and for C programs that try to
    examine backtraces.

    - exidx is used to contain index entries for stack unwinding.
    - extab names sections containing exception unwinding information.

    Essentially, each function that can throw an exception will
    have entries in the exidx and extab sections.

    References:
    - https://developer.arm.com/documentation/ihi0038/b/
    - http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044d/IHI0044D_aaelf.pdf
    - https://stackoverflow.com/a/57463515
  */

  .ARM.extab : {
    *(.ARM.extab* .gnu.linkonce.armextab.*)
  } > flash

  __exidx_start = .;
  .ARM.exidx : {
    *(.ARM.exidx* .gnu.linkonce.armexidx.*)
  } > flash
  __exidx_end = .;

  .copy.table : {
    . = ALIGN(4);
    __copy_table_start__ = .;

    LONG (__etext)
    LONG (__data_start__)
    LONG ((__data_end__ - __data_start__) / 4)

    __copy_table_end__ = .;
  } > flash

  .zero.table : {
    . = ALIGN(4);
    __zero_table_start__ = .;
    __zero_table_end__ = .;
  } > flash

  /**
   * Location counter can end up 2byte aligned with narrow Thumb code but
   * __etext is assumed by startup code to be the LMA of a section in RAM
   * which must be 4byte aligned
   */
  __etext  = ALIGN (4);

  /*
    The `data` section includes mutable variables that have a
    default value and specially marked functions that should execute
    from RAM.

    This data is stored in ROM but is referenced from RAM. The
    program/runtime must copy the data from ROM to RAM on reset.
    This also sets the symbol `_etext` to the start of the relocation
    segment in flash. The startup script copies the data starting at
    `_etext` to `__data_start__` and ends when it reaches `__data_end__`.
    The `_etext` name is a bit unfortunate since it's not the end of
    the text segment, but rather the start of the read-only copy of the
    relocate section in flash.

    Performance sensitive/critical functions can also be placed in
    RAM using this section:
      #define RAMFUNC __attribute__((section(".ramfunc"))) void fast_function(void) RAMFUNC;
    
    For Cortex M0+ cores Micro Trace Buffer can be used to trace the code. It
    is defined at the beginning of RAM and the size of it depends on
    application developer needs.
     
    References:
    * http://www.sco.com/developers/gabi/latest/ch4.sheader.html#special_sections
    * https://www.sourceware.org/binutils/docs/ld/Output-Section-LMA.html#Output-Section-LMA
  */
  
  .mtb : /* MTB buffer address as defined by the hardware */
  {
    . = ALIGN(8);
    _mtb_start = .;
    KEEP(*(.mtb_buf)) /* need to KEEP Micro Trace Buffer as not referenced by application */
    . = ALIGN(8);
    _mtb_end = .;
  } > sram
  
   .data :
  {
    __data_start__ = .;
    *(vtable vtable.*)
    *(.ramfunc .ramfunc.*);
    *(.data .data.* .gnu.linkonce.d.*)
    /* All data end */
    . = ALIGN(4);
    __data_end__ = .;
  } > sram AT > flash

  /*
    The BSS section reserves RAM space for declared but uninitialized
    variables.

    This is zeroed out by the startup script. The start-up script
    zeros out the area of RAM starting at `__zero_table_start__` and ending at
    `__zero_table_end__`.

    This includes `COMMON` which is a bit of a legacy section. GCC
    defaults to `-fno-common` these days so there shouldn't be
    anything in there, but it's included for completeness.

    References:
    * http://www.sco.com/developers/gabi/latest/ch4.sheader.html#special_sections
    * https://en.wikipedia.org/wiki/.bss
    * https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html
      Section -fcommon
  */

  .bss :
  {
    . = ALIGN(4);
    __bss_start__ = .;
    *(.bss .bss.*)
    *(COMMON)
    . = ALIGN(4);
    __bss_end__ = .;
  } > sram

  /*
    Sections for heap and stack

    There are at least two approaches to placement of heap and stack.
    The first is to place heap just after all sections defined lines above
    and put stack at the end of the RAM as it grows down and heap grows up.
    It has one big disadvatage - both regions can clash and cause unpredicted
    behaviour because one region is overriding other. The only guarantee it
    can give is that if the defined stack or heap size is too big
    the linker will give an error.

    The second approach is to place stack first with predefined size - that way
    heap cannot override the stack and vice-versa.

    The first approach is used by CMSIS. Code bellow:
  */

    __HEAP_SIZE = DEFINED(__heap_size) ? __heap_size : 0x20;

    .heap (COPY) :
    {
      . = ALIGN(8);
      __end__ = .;
      PROVIDE(end = .);
      . = . + __HEAP_SIZE;
      . = ALIGN(8);
      __HeapLimit = .;
    } > sram

    .stack (ORIGIN(sram) + LENGTH(sram) - __STACK_SIZE) (COPY) :
    {
      . = ALIGN(8);
      __StackLimit = .;
      . = . + __STACK_SIZE;
      . = ALIGN(8);
      __StackTop = .;
    } > sram
    PROVIDE(__stack = __StackTop);

    ASSERT(__StackLimit >= __HeapLimit, "region RAM overflowed with stack")


  /*
    The second approach bellow.
    __stack symbol is important - without it crt0 will cause a HardFault. 
    This memory layout NEEDs custom _sbrk syscall to work correctly.
    Example custom_syscalls.c file from https://community.silabs.com/s/article/malloc-and-sbrk?language=en_US
    #include <sys/stat.h>
    extern char end;         
    extern char __HeapLimit;  
    caddr_t _sbrk(int incr)
    {
      static char *heap_end;
      char *prev_heap_end;

      if (heap_end == 0) {
        heap_end = &end;
      }

      prev_heap_end = heap_end;
      if ((heap_end + incr) > (char*) &__HeapLimit) {
        //errno = ENOMEM;
        return ((void*)-1); // error - no more memory
      }
      heap_end += incr;

      return (caddr_t) prev_heap_end;
    }
    With this, everything should work correclty 
  */
  
  /*
  .stack (COPY):
  {
    . = ALIGN(8);
    __StackLimit = .;
    . = . + __STACK_SIZE;
    . = ALIGN(8);
    __StackTop = .;
   } > sram
  PROVIDE(__stack = __StackTop);
    
  .heap (__StackTop) (COPY) :
  {
    . = ALIGN(8);
    __end__ = .;
    PROVIDE(end = .);
    . = LENGTH(sram) + ORIGIN(sram);
    . = ALIGN(8);
   __HeapLimit = LENGTH(sram) + ORIGIN(sram); 
  } > sram
  */

} 
